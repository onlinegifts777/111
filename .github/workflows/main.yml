# .github/workflows/main.yml
name: Ghost Intelligence Swarm Email Sender

on:
  workflow_dispatch: # Позволяет запускать вручную из интерфейса GitHub
    inputs:
      total_target_emails:
        description: 'Общее количество писем для отправки (целей из base.txt). Введите 0 для отправки всей базы.'
        required: true
        default: '0'
      test_mode_enabled:
        description: 'Включить тестовый режим (отправка только на TEST_EMAILS из config.py)'
        type: boolean
        required: true
        default: true
      max_parallel_runners:
        description: 'Максимальное количество параллельных GHA-ранеров (чем больше, тем быстрее, но дороже)'
        required: true
        default: '5' # Начни с 2-5 для теста. Для боевого режима можно довести до 20-50 (или выше, если платный аккаунт GHA).
      
jobs:
  # Этот job разделяет цели на пачки и подготавливает матрицу для параллельных запусков
  prepare_dispatch:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set_matrix.outputs.matrix }}
      all_accounts_content: ${{ steps.load_accounts.outputs.content }}
      is_test_mode: ${{ github.event.inputs.test_mode_enabled }}
      batch_size_per_runner_output: ${{ steps.load_config_batch_size.outputs.batch_size_per_runner }}
      all_targets_content: ${{ steps.prepare_targets.outputs.all_targets_content }} # <-- НОВОЕ: Передаем все цели
    steps:
      - uses: actions/checkout@v3 # Клонируем репозиторий, все файлы будут в рабочей директории

      - name: Загрузка всех аккаунтов
        id: load_accounts
        run: |
          # Считываем содержимое файла accounts.txt
          ACCOUNTS_CONTENT=$(cat resources/accounts.txt)
          # Передаем содержимое как output этого шага
          echo "::set-output name=content::$ACCOUNTS_CONTENT"
          echo "Аккаунты загружены. Количество строк: $(echo "$ACCOUNTS_CONTENT" | wc -l)"

      - name: Загрузка config.py для доступа к BATCH_SIZE_PER_RUNNER
        id: load_config_batch_size
        run: |
          # Файл config.py уже находится в рабочей директории благодаря checkout.
          # Поэтому команды 'cp config.py .' или 'cp -r resources/* resources/' НЕ НУЖНЫ,
          # так как они пытаются скопировать файл на самого себя, вызывая ошибку.
          
          # Извлекаем значение BATCH_SIZE_PER_RUNNER из config.py
          BATCH_SIZE=$(grep -oP 'BATCH_SIZE_PER_RUNNER = \K\d+' config.py)
          # Передаем BATCH_SIZE как output этого шага
          echo "batch_size_per_runner=$BATCH_SIZE" >> $GITHUB_OUTPUT
          echo "BATCH_SIZE_PER_RUNNER: $BATCH_SIZE"

      - name: Подготовка целей для рассылки
        id: prepare_targets
        run: |
          TARGETS_TO_PROCESS_FILE="targets_to_process.txt"
          if [ "${{ github.event.inputs.test_mode_enabled }}" == "true" ]; then
            echo "Работаем в тестовом режиме. Получатели будут взяты из config.py -> TEST_EMAILS."
            # В тестовом режиме mailer_worker.py сам переключится на TEST_EMAILS.
            # Поэтому мы просто создаем пустой файл, который будет проигнорирован
            # при нарезке, и `mailer_worker.py` будет использовать `TEST_EMAILS`.
            touch "$TARGETS_TO_PROCESS_FILE"
          else
            # Боевой режим: читаем base.txt
            TARGETS_FILE="resources/base.txt"
            if [ ! -f "$TARGETS_FILE" ]; then
              echo "Ошибка: Файл базы получателей $TARGETS_FILE не найден."
              exit 1
            fi
            
            TOTAL_TARGETS=$(wc -l < "$TARGETS_FILE")
            echo "Всего получателей в base.txt: $TOTAL_TARGETS"

            REQUESTED_TARGETS=${{ github.event.inputs.total_target_emails }}
            if [ "$REQUESTED_TARGETS" -eq 0 ] || [ "$REQUESTED_TARGETS" -gt "$TOTAL_TARGETS" ]; then
                # Отправляем всю базу
                echo "Отправка всей базы получателей."
                cat "$TARGETS_FILE" > "$TARGETS_TO_PROCESS_FILE"
            else
                # Отправляем указанное количество
                echo "Отправка $REQUESTED_TARGETS получателей."
                head -n "$REQUESTED_TARGETS" "$TARGETS_FILE" > "$TARGETS_TO_PROCESS_FILE"
            fi
          fi
          
          PROCESSED_TARGETS_COUNT=$(wc -l < "$TARGETS_TO_PROCESS_FILE")
          echo "Подготовлено получателей: $PROCESSED_TARGETS_COUNT"
          
          # НОВОЕ: Передаем содержимое всего файла целей как output этого шага.
          # Это необходимо, чтобы затем другие job могли получить этот список и нарезать его.
          if [ -s "$TARGETS_TO_PROCESS_FILE" ]; then
              echo "::set-output name=all_targets_content::$(cat "$TARGETS_TO_PROCESS_FILE")"
          else
              echo "::set-output name=all_targets_content::" # Передаем пустую строку, если файл пуст
          fi


      - name: Создание матрицы для GHA ранеров
        id: set_matrix
        run: |
          # Используем output предыдущего шага для BATCH_SIZE
          BATCH_SIZE=${{ steps.load_config_batch_size.outputs.batch_size_per_runner }}
          IS_TEST_MODE="${{ github.event.inputs.test_mode_enabled }}"
          
          # Получаем содержимое всех целей из output этого же job (переданное выше)
          ALL_TARGETS_CONTENT="${{ steps.prepare_targets.outputs.all_targets_content }}"

          MATRIX_CONFIG_ITEMS=""
          RUNNER_ID=1

          if [ "$IS_TEST_MODE" == "true" ]; then
            # В тестовом режиме запускаем ОДИН ранер, который сам будет использовать TEST_EMAILS
            MATRIX_CONFIG_ITEMS="{\"runner_id\": 1, \"targets_offset\": 0, \"targets_limit\": ${BATCH_SIZE}}"
          elif [ -n "$ALL_TARGETS_CONTENT" ]; then # Проверяем, что ALL_TARGETS_CONTENT не пустой
            # Создаем временный файл из содержимого, чтобы посчитать строки
            echo "$ALL_TARGETS_CONTENT" > temp_targets_for_matrix.txt
            TOTAL_TARGETS=$(wc -l < temp_targets_for_matrix.txt)
            rm temp_targets_for_matrix.txt # Удаляем временный файл
            
            echo "Всего целей для разбивки на пачки: $TOTAL_TARGETS"
            
            OFFSET=0
            while [ "$OFFSET" -lt "$TOTAL_TARGETS" ]; do
                MATRIX_CONFIG_ITEMS+="{\"runner_id\": ${RUNNER_ID}, \"targets_offset\": ${OFFSET}, \"targets_limit\": ${BATCH_SIZE}},"
                OFFSET=$((OFFSET + BATCH_SIZE))
                ((RUNNER_ID++))
            done
            # Удаляем последнюю запятую, если есть элементы
            MATRIX_CONFIG_ITEMS=${MATRIX_CONFIG_ITEMS%,}
          else
            echo "Нет целей для рассылки в боевом режиме. Матрица пуста."
            MATRIX_CONFIG_ITEMS=""
          fi
          
          MATRIX_CONFIG="{\"include\": [${MATRIX_CONFIG_ITEMS}]}"
          echo "::set-output name=matrix::${MATRIX_CONFIG}"
          echo "Сгенерированная матрица для запуска: ${MATRIX_CONFIG}"

  # Этот job будет запускаться параллельно на нескольких GHA-ранерах, каждый для СВОЕЙ ПАЧКИ писем
  send_emails_swarm:
    needs: prepare_dispatch
    runs-on: ubuntu-latest # Каждый запуск будет с нового, чистого IP-адреса GitHub
    strategy:
      fail-fast: false # Если один ранер упадет, остальные продолжат работу
      matrix: ${{ fromJson(needs.prepare_dispatch.outputs.matrix) }}
      max-parallel: ${{ github.event.inputs.max_parallel_runners }} # Ограничиваем количество параллельных ранеров
    
    steps:
      - uses: actions/checkout@v3 # Клонируем репозиторий, все файлы будут в рабочей директории

      - name: Установка Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Установка зависимостей
        run: pip install aiosmtplib

      - name: Загрузка файлов ресурсов
        run: |
          # Папка resources/ и config.py уже присутствуют после actions/checkout.
          # Создаем ее на всякий случай, если она вдруг отсутствовала бы (хотя не должна при обычном checkout).
          mkdir -p resources
          
          # Записываем аккаунты из output предыдущего job (полный список).
          # Эта команда перезапишет исходный resources/accounts.txt на каждом ранере.
          echo "${{ needs.prepare_dispatch.outputs.all_accounts_content }}" > resources/accounts.txt
          
          # Обработка целей для текущего ранера:
          if [ "${{ needs.prepare_dispatch.outputs.is_test_mode }}" == "true" ]; then
            echo "# Test mode active, mailer_worker will use TEST_EMAILS from config.py" > resources/base.txt
          else
            # Получаем полное содержимое целей из prepare_dispatch job.
            # Это содержимое было передано как output job.
            ALL_TARGETS_CONTENT="${{ needs.prepare_dispatch.outputs.all_targets_content }}"
            
            # Сохраняем полное содержимое во временный файл, чтобы затем из него нарезать пачку.
            echo "$ALL_TARGETS_CONTENT" > full_targets_temp.txt
            
            OFFSET=${{ matrix.targets_offset }}
            LIMIT=${{ matrix.targets_limit }}
            
            # Извлекаем нужный фрагмент из временного файла и записываем в resources/base.txt
            tail -n +$((OFFSET + 1)) full_targets_temp.txt | head -n "$LIMIT" > resources/base.txt
            
            # Удаляем временный файл после использования
            rm full_targets_temp.txt
          fi
          
          echo "--- Содержимое файлов ресурсов после загрузки ---"
          ls -l resources/
          echo "resources/accounts.txt (первые 3 строки):"
          head -n 3 resources/accounts.txt || true
          echo "resources/base.txt (содержимое):"
          cat resources/base.txt || true # Для пачки покажем все

      - name: Запуск Swarm Email Sender
        env:
          # Передаем полный список аккаунтов и текущую пачку целей как переменные окружения
          # Вашему mailer_worker.py нужно будет считывать эти переменные.
          GHA_ACCOUNTS: "${{ needs.prepare_dispatch.outputs.all_accounts_content }}" 
          GHA_TARGETS: "$(cat resources/base.txt)" # Содержимое файла resources/base.txt
          GHA_RUNNER_ID: ${{ matrix.runner_id }} # Передаем ID текущего ранера для логгирования
        run: python mailer_worker.py

      - name: Сохранение логов рассылки
        uses: actions/upload-artifact@v3
        with:
          name: logs-${{ github.run_id }}-${{ matrix.runner_id }}
          path: |
            sent_log.csv
            error_log.csv
          if-no-files-found: ignore # Не падать, если логов нет
