# .github/workflows/main.yml
# Название вашего рабочего процесса
name: Ghost Intelligence Swarm Email Sender

# Событие, которое запускает этот рабочий процесс
on:
  workflow_dispatch: # Позволяет запускать вручную из интерфейса GitHub
    inputs:
      total_target_emails:
        description: 'Общее количество писем для отправки (целей из base.txt). Введите 0 для отправки всей базы.'
        required: true
        default: '0'
      test_mode_enabled:
        description: 'Включить тестовый режим (отправка только на TEST_EMAILS из config.py)'
        type: boolean
        required: true
        default: true
      max_parallel_runners:
        description: 'Максимальное количество параллельных GHA-ранеров (чем больше, тем быстрее, но дороже)'
        required: true
        default: '5' # Начните с 2-5 для теста. Для боевого режима можно довести до 20-50 (или выше, если платный аккаунт GHA).
      
# Определяем Jobs (работы) для выполнения
jobs:
  # Job для подготовки и распределения задач
  prepare_dispatch:
    runs-on: ubuntu-latest # Используем последний образ Ubuntu
    # Определяем, какие выводы (outputs) будут доступны другим Jobs
    outputs:
      matrix: ${{ steps.set_matrix.outputs.matrix }} # Матрица для параллельного запуска
      all_accounts_content: ${{ steps.load_accounts.outputs.content }} # Все аккаунты
      is_test_mode: ${{ github.event.inputs.test_mode_enabled }} # Флаг тестового режима
    steps:
      - uses: actions/checkout@v3 # Шаг для клонирования вашего репозитория

      - name: Загрузка всех аккаунтов
        id: load_accounts # Уникальный ID для этого шага
        run: |
          # ОБНОВЛЕНИЕ ЗДЕСЬ: Объединяем все аккаунты в одну строку, разделяя их '|||'.
          # Это необходимо, чтобы GitHub Actions мог правильно передать многострочные данные
          # как единый 'output' в следующий Job.
          ACCOUNTS_CONTENT=$(cat resources/accounts.txt | tr '\n' '|||')
          # Удаляем '|||' в конце строки, если он есть, чтобы не было лишнего разделителя.
          ACCOUNTS_CONTENT=$(echo "$ACCOUNTS_CONTENT" | sed 's/|||$//')
          
          # Записываем обработанное содержимое в output для использования другими Jobs
          echo "content=$ACCOUNTS_CONTENT" >> $GITHUB_OUTPUT 
          echo "Аккаунты загружены. Количество строк: $(echo "$ACCOUNTS_CONTENT" | tr -d ' ' | tr -s '|||' '\n' | wc -l)"

      - name: Загрузка config.py для доступа к BATCH_SIZE_PER_RUNNER
        run: |
          cp config.py . # Копируем config.py в текущий каталог
          # Извлекаем значение BATCH_SIZE_PER_RUNNER из config.py
          # Если строка не найдена, используем значение по умолчанию (100)
          BATCH_SIZE=$(grep -oP 'BATCH_SIZE_PER_RUNNER = \K\d+' config.py || echo "100") 
          # Сохраняем значение в переменную окружения для последующих шагов в этом Job
          echo "BATCH_SIZE_PER_RUNNER=$BATCH_SIZE" >> $GITHUB_ENV 
          echo "BATCH_SIZE_PER_RUNNER: $BATCH_SIZE"

      - name: Подготовка целей для рассылки и сохранение в артефакт
        id: prepare_targets
        run: |
          TARGETS_FILE="resources/base.txt" # Путь к вашему файлу базы получателей
          PROCESSED_TARGETS_FILE="processed_targets_for_dispatch.txt" # Имя файла, который будет создан и загружен как артефакт

          if [ "${{ github.event.inputs.test_mode_enabled }}" == "true" ]; then
            echo "Работаем в тестовом режиме. Получатели будут взяты из config.py -> TEST_EMAILS."
            # В тестовом режиме создаем пустой файл-заглушку. mailer_worker.py сам переключится на TEST_EMAILS.
            touch "$PROCESSED_TARGETS_FILE"
          else
            if [ ! -f "$TARGETS_FILE" ]; then
              echo "Ошибка: Файл базы получателей $TARGETS_FILE не найден. Убедитесь, что resources/base.txt существует и заполнен."
              exit 1 # Выход с ошибкой, если файл не найден
            fi
            
            TOTAL_TARGETS=$(wc -l < "$TARGETS_FILE")
            echo "Всего получателей в base.txt: $TOTAL_TARGETS"

            REQUESTED_TARGETS=${{ github.event.inputs.total_target_emails }}
            if [ "$REQUESTED_TARGETS" -eq 0 ] || [ "$REQUESTED_TARGETS" -gt "$TOTAL_TARGETS" ]; then
                echo "Отправка всей базы получателей."
                cat "$TARGETS_FILE" > "$PROCESSED_TARGETS_FILE"
            else
                echo "Отправка $REQUESTED_TARGETS получателей."
                head -n "$REQUESTED_TARGETS" "$TARGETS_FILE" > "$PROCESSED_TARGETS_FILE"
            fi
          fi
          
          PROCESSED_TARGETS_COUNT=$(wc -l < "$PROCESSED_TARGETS_FILE")
          echo "Подготовлено получателей: $PROCESSED_TARGETS_COUNT"
          # Сохраняем имя файла в output, чтобы его можно было использовать в другом шаге (для upload-artifact)
          echo "processed_targets_filename=$PROCESSED_TARGETS_FILE" >> $GITHUB_OUTPUT

      - name: Загрузка файла с целями как артефакта
        # ОБНОВЛЕНИЕ ЗДЕСЬ: Используем actions/upload-artifact@v4 (исправлена ошибка v3)
        uses: actions/upload-artifact@v4 
        with:
          name: targets-for-dispatch # Имя артефакта, по которому его можно будет скачать
          path: ${{ steps.prepare_targets.outputs.processed_targets_filename }} # Путь к файлу, который загружаем

      - name: Создание матрицы для GHA ранеров
        id: set_matrix
        run: |
          BATCH_SIZE=${{ env.BATCH_SIZE_PER_RUNNER }} # Доступно из GITHUB_ENV
          IS_TEST_MODE="${{ github.event.inputs.test_mode_enabled }}"
          TARGETS_FILENAME="${{ steps.prepare_targets.outputs.processed_targets_filename }}"
          
          MATRIX_CONFIG_ITEMS=""
          RUNNER_ID=1

          if [ "$IS_TEST_MODE" == "true" ]; then
            # В тестовом режиме запускаем ОДИН ранер. mailer_worker.py сам использует TEST_EMAILS.
            MATRIX_CONFIG_ITEMS="{\"runner_id\": 1, \"targets_offset\": 0, \"targets_limit\": ${BATCH_SIZE}}"
          elif [ -s "$TARGETS_FILENAME" ]; then # Проверяем, что файл с целями не пустой
            TOTAL_TARGETS=$(wc -l < "$TARGETS_FILENAME")
            echo "Всего целей для разбивки на пачки: $TOTAL_TARGETS"
            
            OFFSET=0
            while [ "$OFFSET" -lt "$TOTAL_TARGETS" ]; do
                # Создаем элемент матрицы для каждой пачки
                MATRIX_CONFIG_ITEMS+="{\"runner_id\": ${RUNNER_ID}, \"targets_offset\": ${OFFSET}, \"targets_limit\": ${BATCH_SIZE}},"
                OFFSET=$((OFFSET + BATCH_SIZE))
                ((RUNNER_ID++))
            done
            # Удаляем последнюю запятую, если она есть, чтобы JSON был корректным
            MATRIX_CONFIG_ITEMS="${MATRIX_CONFIG_ITEMS%,}"
          else
            echo "Нет целей для рассылки в боевом режиме. Матрица пуста. Workflow завершится."
            MATRIX_CONFIG_ITEMS="" # Если нет целей, матрица будет пустой, и send_emails_swarm не запустится
          fi
          
          MATRIX_CONFIG="{\"include\": [${MATRIX_CONFIG_ITEMS}]}"
          # Сохраняем готовую JSON-матрицу в output для использования следующим Job'ом
          echo "matrix=$MATRIX_CONFIG" >> $GITHUB_OUTPUT

  # Job для параллельной отправки писем
  send_emails_swarm:
    needs: prepare_dispatch # Этот Job зависит от успешного завершения prepare_dispatch
    runs-on: ubuntu-latest # Каждый запуск Job'а будет на новом, чистом IP-адресе GitHub
    strategy:
      fail-fast: false # Если один ранер (экземпляр Job'а) упадет, остальные продолжат работу
      matrix: ${{ fromJson(needs.prepare_dispatch.outputs.matrix) }} # Используем матрицу, созданную в prepare_dispatch
      max-parallel: ${{ github.event.inputs.max_parallel_runners }} # Ограничиваем количество параллельных ранеров

    steps:
      - uses: actions/checkout@v3 # Клонируем репозиторий

      - name: Установка Python
        uses: actions/setup-python@v4 # Используем actions/setup-python@v4
        with:
          python-version: '3.10' # Указываем версию Python

      - name: Установка зависимостей
        run: pip install aiosmtplib # Устанавливаем необходимую библиотеку

      - name: Создание папки ресурсов
        run: mkdir -p resources # Создаем папку resources, если её нет

      # Шаг для скачивания артефакта с целями
      - name: Скачивание файла с целями
        # ОБНОВЛЕНИЕ ЗДЕСЬ: Используем actions/download-artifact@v4 (исправлена ошибка v3)
        uses: actions/download-artifact@v4 
        with:
          name: targets-for-dispatch # Имя артефакта, который мы загрузили в предыдущем Job'е
          path: . # Скачиваем артефакт в текущий рабочий каталог

      - name: Загрузка файлов ресурсов
        run: |
          cp config.py . # Копируем config.py
          cp -r resources/* resources/ # Копируем содержимое папки resources

          # Записываем аккаунты, полученные как output из prepare_dispatch, в файл accounts.txt
          # Это будет полный список аккаунтов для mailer_worker.py
          echo "${{ needs.prepare_dispatch.outputs.all_accounts_content }}" > resources/accounts.txt
          
          # Извлекаем свою пачку получателей для текущего ранера из скачанного файла
          if [ "${{ needs.prepare_dispatch.outputs.is_test_mode }}" == "true" ]; then
            echo "# Test mode active, mailer_worker will use TEST_EMAILS from config.py" > resources/base.txt
          else
            TARGETS_FILENAME="processed_targets_for_dispatch.txt" # Имя файла, который мы скачали как артефакт
            OFFSET=${{ matrix.targets_offset }} # Смещение для текущей пачки
            LIMIT=${{ matrix.targets_limit }} # Количество целей в текущей пачке
            
            # Используем tail и head для выбора нужного диапазона получателей
            tail -n +$((OFFSET + 1)) "$TARGETS_FILENAME" | head -n "$LIMIT" > resources/base.txt
          fi
          
          echo "--- Содержимое файлов ресурсов после загрузки ---"
          ls -l resources/
          echo "resources/accounts.txt (первые 3 строки):"
          head -n 3 resources/accounts.txt || true # Показываем первые 3 строки аккаунтов
          echo "resources/base.txt (содержимое):"
          cat resources/base.txt || true # Показываем всю текущую пачку получателей

      - name: Запуск Swarm Email Sender
        # Передаем переменные окружения в ваш Python-скрипт
        env:
          GHA_ACCOUNTS: "${{ needs.prepare_dispatch.outputs.all_accounts_content }}" # Полный список аккаунтов
          GHA_TARGETS: "$(cat resources/base.txt)" # Текущая пачка получателей
          GHA_RUNNER_ID: ${{ matrix.runner_id }} # ID текущего ранера для логгирования
        run: python mailer_worker.py # Запускаем ваш Python-скрипт

      - name: Сохранение логов рассылки
        # ОБНОВЛЕНИЕ ЗДЕСЬ: Используем actions/upload-artifact@v4 (исправлена ошибка v3)
        uses: actions/upload-artifact@v4 
        with:
          name: logs-${{ github.run_id }}-${{ matrix.runner_id }} # Уникальное имя для архива логов
          path: |
            sent_log.csv # Путь к файлу логов отправленных
            error_log.csv # Путь к файлу логов ошибок
          if-no-files-found: ignore # Не падать, если файлы логов не найдены
